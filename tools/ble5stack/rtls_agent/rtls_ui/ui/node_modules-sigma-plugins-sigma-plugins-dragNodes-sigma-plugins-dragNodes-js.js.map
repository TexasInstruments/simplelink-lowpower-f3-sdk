{"version":3,"sources":["webpack:///./node_modules/sigma/plugins/sigma.plugins.dragNodes/sigma.plugins.dragNodes.js"],"names":[],"mappings":";;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,MAAM;AACpB,cAAc,SAAS;AACvB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,oDAAoD,UAAU,EAAE;AAChE;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,4BAA4B,2CAA2C;AACvE;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,0BAA0B,yCAAyC;AACnE;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,cAAc,MAAM;AACpB,cAAc,SAAS;AACvB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA,cAAc,MAAM;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,CAAC","file":"node_modules-sigma-plugins-sigma-plugins-dragNodes-sigma-plugins-dragNodes-js.js","sourcesContent":["/**\n * This plugin provides a method to drag & drop nodes. Check the\n * sigma.plugins.dragNodes function doc or the examples/basic.html &\n * examples/api-candy.html code samples to know more.\n */\n(function() {\n  'use strict';\n\n  if (typeof sigma === 'undefined')\n    throw 'sigma is not declared';\n\n  sigma.utils.pkg('sigma.plugins');\n\n\n  /**\n   * This function will add `mousedown`, `mouseup` & `mousemove` events to the\n   * nodes in the `overNode`event to perform drag & drop operations. It uses\n   * `linear interpolation` [http://en.wikipedia.org/wiki/Linear_interpolation]\n   * and `rotation matrix` [http://en.wikipedia.org/wiki/Rotation_matrix] to\n   * calculate the X and Y coordinates from the `cam` or `renderer` node\n   * attributes. These attributes represent the coordinates of the nodes in\n   * the real container, not in canvas.\n   *\n   * Fired events:\n   * *************\n   * startdrag  Fired at the beginning of the drag.\n   * drag       Fired while the node is dragged.\n   * drop       Fired at the end of the drag if the node has been dragged.\n   * dragend    Fired at the end of the drag.\n   *\n   * Recognized parameters:\n   * **********************\n   * @param  {sigma}    s        The related sigma instance.\n   * @param  {renderer} renderer The related renderer instance.\n   */\n  function DragNodes(s, renderer) {\n    sigma.classes.dispatcher.extend(this);\n\n    // A quick hardcoded rule to prevent people from using this plugin with the\n    // WebGL renderer (which is impossible at the moment):\n    // if (\n    //   sigma.renderers.webgl &&\n    //   renderer instanceof sigma.renderers.webgl\n    // )\n    //   throw new Error(\n    //     'The sigma.plugins.dragNodes is not compatible with the WebGL renderer'\n    //   );\n\n    // Init variables:\n    var _self = this,\n      _s = s,\n      _body = document.body,\n      _renderer = renderer,\n      _mouse = renderer.container.lastChild,\n      _camera = renderer.camera,\n      _node = null,\n      _prefix = '',\n      _hoverStack = [],\n      _hoverIndex = {},\n      _isMouseDown = false,\n      _isMouseOverCanvas = false,\n      _drag = false;\n\n    if (renderer instanceof sigma.renderers.svg) {\n        _mouse = renderer.container.firstChild;\n    }\n\n    // It removes the initial substring ('read_') if it's a WegGL renderer.\n    if (renderer instanceof sigma.renderers.webgl) {\n      _prefix = renderer.options.prefix.substr(5);\n    } else {\n      _prefix = renderer.options.prefix;\n    }\n\n    renderer.bind('overNode', nodeMouseOver);\n    renderer.bind('outNode', treatOutNode);\n    renderer.bind('click', click);\n\n    _s.bind('kill', function() {\n      _self.unbindAll();\n    });\n\n    /**\n     * Unbind all event listeners.\n     */\n    this.unbindAll = function() {\n      _mouse.removeEventListener('mousedown', nodeMouseDown);\n      _body.removeEventListener('mousemove', nodeMouseMove);\n      _body.removeEventListener('mouseup', nodeMouseUp);\n      _renderer.unbind('overNode', nodeMouseOver);\n      _renderer.unbind('outNode', treatOutNode);\n    }\n\n    // Calculates the global offset of the given element more accurately than\n    // element.offsetTop and element.offsetLeft.\n    function calculateOffset(element) {\n      var style = window.getComputedStyle(element);\n      var getCssProperty = function(prop) {\n        return parseInt(style.getPropertyValue(prop).replace('px', '')) || 0;\n      };\n      return {\n        left: element.getBoundingClientRect().left + getCssProperty('padding-left'),\n        top: element.getBoundingClientRect().top + getCssProperty('padding-top')\n      };\n    };\n\n    function click(event) {\n      // event triggered at the end of the click\n      _isMouseDown = false;\n      _body.removeEventListener('mousemove', nodeMouseMove);\n      _body.removeEventListener('mouseup', nodeMouseUp);\n\n      if (!_hoverStack.length) {\n        _node = null;\n      }\n    };\n\n    function nodeMouseOver(event) {\n      // Don't treat the node if it is already registered\n      if (_hoverIndex[event.data.node.id]) {\n        return;\n      }\n\n      // Add node to array of current nodes over\n      _hoverStack.push(event.data.node);\n      _hoverIndex[event.data.node.id] = true;\n\n      if(_hoverStack.length && ! _isMouseDown) {\n        // Set the current node to be the last one in the array\n        _node = _hoverStack[_hoverStack.length - 1];\n        _mouse.addEventListener('mousedown', nodeMouseDown);\n      }\n    };\n\n    function treatOutNode(event) {\n      // Remove the node from the array\n      var indexCheck = _hoverStack.map(function(e) { return e; }).indexOf(event.data.node);\n      _hoverStack.splice(indexCheck, 1);\n      delete _hoverIndex[event.data.node.id];\n\n      if(_hoverStack.length && ! _isMouseDown) {\n        // On out, set the current node to be the next stated in array\n        _node = _hoverStack[_hoverStack.length - 1];\n      } else {\n        _mouse.removeEventListener('mousedown', nodeMouseDown);\n      }\n    };\n\n    function nodeMouseDown(event) {\n      _isMouseDown = true;\n      var size = _s.graph.nodes().length;\n\n      // when there is only node in the graph, the plugin cannot apply\n      // linear interpolation. So treat it as if a user is dragging\n      // the graph\n      if (_node && size > 1) {\n        _mouse.removeEventListener('mousedown', nodeMouseDown);\n        _body.addEventListener('mousemove', nodeMouseMove);\n        _body.addEventListener('mouseup', nodeMouseUp);\n\n        // Do not refresh edgequadtree during drag:\n        var k,\n            c;\n        for (k in _s.cameras) {\n          c = _s.cameras[k];\n          if (c.edgequadtree !== undefined) {\n            c.edgequadtree._enabled = false;\n          }\n        }\n\n        // Deactivate drag graph.\n        _renderer.settings({mouseEnabled: false, enableHovering: false});\n        _s.refresh();\n\n        _self.dispatchEvent('startdrag', {\n          node: _node,\n          captor: event,\n          renderer: _renderer\n        });\n      }\n    };\n\n    function nodeMouseUp(event) {\n      _isMouseDown = false;\n      _mouse.addEventListener('mousedown', nodeMouseDown);\n      _body.removeEventListener('mousemove', nodeMouseMove);\n      _body.removeEventListener('mouseup', nodeMouseUp);\n\n      // Allow to refresh edgequadtree:\n      var k,\n          c;\n      for (k in _s.cameras) {\n        c = _s.cameras[k];\n        if (c.edgequadtree !== undefined) {\n          c.edgequadtree._enabled = true;\n        }\n      }\n\n      // Activate drag graph.\n      _renderer.settings({mouseEnabled: true, enableHovering: true});\n      _s.refresh();\n\n      if (_drag) {\n        _self.dispatchEvent('drop', {\n          node: _node,\n          captor: event,\n          renderer: _renderer\n        });\n      }\n      _self.dispatchEvent('dragend', {\n        node: _node,\n        captor: event,\n        renderer: _renderer\n      });\n\n      _drag = false;\n      _node = null;\n    };\n\n    function nodeMouseMove(event) {\n      if(navigator.userAgent.toLowerCase().indexOf('firefox') > -1) {\n        clearTimeout(timeOut);\n        var timeOut = setTimeout(executeNodeMouseMove, 0);\n      } else {\n        executeNodeMouseMove();\n      }\n\n      function executeNodeMouseMove() {\n        var offset = calculateOffset(_renderer.container),\n            x = event.clientX - offset.left,\n            y = event.clientY - offset.top,\n            cos = Math.cos(_camera.angle),\n            sin = Math.sin(_camera.angle),\n            nodes = _s.graph.nodes(),\n            ref = [];\n\n        // Getting and derotating the reference coordinates.\n        for (var i = 0; i < 2; i++) {\n          var n = nodes[i];\n          var aux = {\n            x: n.x * cos + n.y * sin,\n            y: n.y * cos - n.x * sin,\n            renX: n[_prefix + 'x'],\n            renY: n[_prefix + 'y'],\n          };\n          ref.push(aux);\n        }\n\n        // Applying linear interpolation.\n        // if the nodes are on top of each other, we use the camera ratio to interpolate\n        if (ref[0].x === ref[1].x && ref[0].y === ref[1].y) {\n          var xRatio = (ref[0].renX === 0) ? 1 : ref[0].renX;\n          var yRatio = (ref[0].renY === 0) ? 1 : ref[0].renY;\n          x = (ref[0].x / xRatio) * (x - ref[0].renX) + ref[0].x;\n          y = (ref[0].y / yRatio) * (y - ref[0].renY) + ref[0].y;\n        } else {\n          var xRatio = (ref[1].renX - ref[0].renX) / (ref[1].x - ref[0].x);\n          var yRatio = (ref[1].renY - ref[0].renY) / (ref[1].y - ref[0].y);\n\n          // if the coordinates are the same, we use the other ratio to interpolate\n          if (ref[1].x === ref[0].x) {\n            xRatio = yRatio;\n          }\n\n          if (ref[1].y === ref[0].y) {\n            yRatio = xRatio;\n          }\n\n          x = (x - ref[0].renX) / xRatio + ref[0].x;\n          y = (y - ref[0].renY) / yRatio + ref[0].y;\n        }\n\n        // Rotating the coordinates.\n        _node.x = x * cos - y * sin;\n        _node.y = y * cos + x * sin;\n\n        _s.refresh();\n\n        _drag = true;\n        _self.dispatchEvent('drag', {\n          node: _node,\n          captor: event,\n          renderer: _renderer\n        });\n      }\n    };\n  };\n\n  /**\n   * Interface\n   * ------------------\n   *\n   * > var dragNodesListener = sigma.plugins.dragNodes(s, s.renderers[0]);\n   */\n  var _instance = {};\n\n  /**\n   * @param  {sigma} s The related sigma instance.\n   * @param  {renderer} renderer The related renderer instance.\n   */\n  sigma.plugins.dragNodes = function(s, renderer) {\n    // Create object if undefined\n    if (!_instance[s.id]) {\n      _instance[s.id] = new DragNodes(s, renderer);\n    }\n\n    s.bind('kill', function() {\n      sigma.plugins.killDragNodes(s);\n    });\n\n    return _instance[s.id];\n  };\n\n  /**\n   * This method removes the event listeners and kills the dragNodes instance.\n   *\n   * @param  {sigma} s The related sigma instance.\n   */\n  sigma.plugins.killDragNodes = function(s) {\n    if (_instance[s.id] instanceof DragNodes) {\n      _instance[s.id].unbindAll();\n      delete _instance[s.id];\n    }\n  };\n\n}).call(window);\n"],"sourceRoot":""}