/*
 *  ======== ti_ble_mesh_config.h ========
 *  Configured BLE Mesh module definitions
 *
 *  DO NOT EDIT - This file is generated by the SysConfig tool.
 */

#ifndef TI_BLE_MESH_CONFIG_H
#define TI_BLE_MESH_CONFIG_H

%%{
/*
 *  ======== ti_ble_mesh_config.h.xdt ========
 */

// Get the ble module
const ble = system.modules["/ti/ble5stack/ble"].$static;

const common = system.getScript("/ti/ble5stack/ble_common.js");

%%}

% if(!ble.disableDisplayModule && !ble.nwpMode)
% {
/******************************************************************************
* Mesh App
*******************************************************************************/
// Use the application menu
#define USE_APP_MENU

% }
/******************************************************************************
* Mesh
*******************************************************************************/
/* This option enables Bluetooth Mesh support. The specific features that are
 * available may depend on other features that have been enabled in the stack */
#define CONFIG_BT_MESH 1

% if(ble.useExtAdv)
% {
/* ------------------------------------------------------------------------- */
// Extended Advertise
/* ------------------------------------------------------------------------- */
#define ZEPHYR_ADV_EXT

% }
% if(ble.staticProv)
% {
/* ------------------------------------------------------------------------- */
// Static Provisioning
/* ------------------------------------------------------------------------- */
#define USE_STATIC_PROVISIONING
#define DEVICE_OWN_ADDRESS `ble.deviceOwnAddress`

% }
% if(ble.nwpMode)
% {
/* ------------------------------------------------------------------------- */
// EmbeddedRPC
/* ------------------------------------------------------------------------- */
/* Enables the use of EmbeddedRPC
*/
#define MESH_ERPC

% }
/* ------------------------------------------------------------------------- */
// Settings
/* ------------------------------------------------------------------------- */
% if(ble.useNV)
% {
/* When selected, the Zephyr settings module will take care of storing (and
 * restoring) the mesh node state and configuration persistently in flash.
 * When this option has been enabled, it’s important that the application
 * makes a call to settings_load() after having called bt_mesh_init(). */
#define CONFIG_BT_SETTINGS 1

% }
% else
% {
#define ERPC_REMOVE__settings_load_wrapper

% }
/* ------------------------------------------------------------------------- */
// Net Layer
/* ------------------------------------------------------------------------- */

/* This option specifies how many application keys the device can store per
 * network. */
#define CONFIG_BT_MESH_APP_KEY_COUNT `ble.appKeyCount`

/* This option specifies how many subnets a Mesh network can participate in at
 * the same time. */
#define CONFIG_BT_MESH_SUBNET_COUNT `ble.subnetCount`

/* Macros to initialize app_keys and subnet_keys */
#define ZEPHYR_APP_KEYS_INITIATOR \
% let i = 0;
% for (i = 0; i < ble.appKeyCount; i++)
% {
    {.app_idx = BT_MESH_KEY_UNUSED, .net_idx = BT_MESH_KEY_UNUSED}, \
% }

#define ZEPHYR_SBUNET_KEYS_INITIATOR \
% for (i = 0; i < ble.subnetCount; i++)
% {
    {.net_idx = BT_MESH_KEY_UNUSED}, \
% }

/* Number of messages that are cached for the network. This helps prevent
 * unnecessary decryption operations and unnecessary relays. This option is
 * similar to the replay protection list, but has a different purpose. */
#define CONFIG_BT_MESH_MSG_CACHE_SIZE `ble.msgCacheSize`

/* ------------------------------------------------------------------------- */


/* ------------------------------------------------------------------------- */
// Transport Layer
/* ------------------------------------------------------------------------- */

/* Number of advertising buffers available. This should be chosen based on what
 * kind of features the local node should have. E.g. a relay will perform
 * better the more buffers it has. Another thing to consider is outgoing
 * segmented messages. There must be at least three more advertising buffers
 * than the maximum supported outgoing segment count (BT_MESH_TX_SEG_MAX). */
#define CONFIG_BT_MESH_ADV_BUF_COUNT `ble.numAdvBuf`

// ------------------
// Transport Layer TX

/* Maximum number of simultaneous outgoing multi-segment and/or reliable
 * messages. */
#define CONFIG_BT_MESH_TX_SEG_MSG_COUNT `ble.maxNumOfSegMsgTX`

/* Maximum number of segments supported for outgoing messages. This value
 * should typically be fine-tuned based on what models the local node supports,
 * i.e. what�s the largest message payload that the node needs to be able to
 * send. This value affects memory consumption, which is why the default is
 * lower than the maximum that the specification would allow (32 segments).
 * The maximum outgoing SDU size is 12 times this number (out of which 4 or 8
 * bytes is used for the Transport Layer MIC). For example, 5 segments means
 * the maximum SDU size is 60 bytes, which leaves 56 bytes for application
 * layer data using a 4-byte MIC and 52 bytes using an 8-byte MIC. */
#define CONFIG_BT_MESH_TX_SEG_MAX `ble.maxNumSegInMsgTX`

// ------------------
// Transport Layer RX

/* Maximum number of simultaneous incoming multi-segment and/or reliable
 * messages. */
#define CONFIG_BT_MESH_RX_SEG_MSG_COUNT `ble.maxNumSegMsgRX`

/* Maximum incoming Upper Transport Access PDU length. This determines also
* how many segments incoming segmented messages can have. Each segment can
* contain 12 bytes, so this value should be set to a multiple of 12 to avoid
* wasted memory. The minimum requirement is 2 segments (24 bytes) whereas
* the maximum supported by the Mesh specification is 32 segments (384 bytes). */
#define CONFIG_BT_MESH_RX_SEG_MAX `ble.maxNumSegInMsgRX`

/* ------------------------------------------------------------------------- */


/* ------------------------------------------------------------------------- */
// Model Layer
/* ------------------------------------------------------------------------- */

/* This option specifies how many group addresses each model can at most be
 * subscribed to. */
#define CONFIG_BT_MESH_MODEL_GROUP_COUNT `ble.modelGroupAddrCount`

/* This option specifies how many application keys each model can at most be
 * bound to. */
#define CONFIG_BT_MESH_MODEL_KEY_COUNT `ble.modelAppKeysCount`

%if(ble.modelExtensions)
% {
/* Enable support for the model extension concept, allowing the Access layer to
 * know about Mesh model relationships.*/
#define CONFIG_BT_MESH_MODEL_EXTENSIONS 1
% }
%else
% {
#define ERPC_REMOVE__bt_mesh_model_extend_wrapper
% }
/* ------------------------------------------------------------------------- */


%if(ble.advbearer || ble.gattBearer)
% {
/* ------------------------------------------------------------------------- */
// Provisioning
/* ------------------------------------------------------------------------- */

/* Enable this option to be a Provisionable Node. */
#define CONFIG_BT_MESH_PROV 1
% }

/* Configures the timeout for re-transmitting provisioning packets */
#define CONFIG_BT_MESH_PB_ADV_RETRANS_TIMEOUT `ble.provTimeout`

%if(ble.advbearer)
% {
/* Enable this option to allow the device to be provisioned over the
 * advertising bearer. */
#define CONFIG_BT_MESH_PB_ADV 1
% }

%if(ble.gattBearer)
% {
/* Enable this option to allow the device to be provisioned over GATT. */
#define CONFIG_BT_MESH_PB_GATT 1
% }
%if(ble.advbearer || ble.gattBearer)
% {
/* ------------------------------------------------------------------------- */

% }
%if(ble.relay)
% {
/* ------------------------------------------------------------------------- */
// Relay
/* ------------------------------------------------------------------------- */

/* Enable this option to be able to act as a Relay Node. */
#define CONFIG_BT_MESH_RELAY 1

#define CONFIG_BT_MESH_RELAY_ENABLED 1
/* ------------------------------------------------------------------------- */

% }

/* ------------------------------------------------------------------------- */
// Proxy
/* ------------------------------------------------------------------------- */
%if(ble.proxy || ble.gattBearer)
% {

/* Enable this option to be able to act as a Proxy Node. */
#define CONFIG_BT_MESH_PROXY 1

/* This option enables support for the Mesh GATT Proxy Service, i.e. the
 * ability to act as a proxy between a Mesh GATT Client and a Mesh network. */
#define CONFIG_BT_MESH_GATT_PROXY 1

/* This option specifies how many Proxy Filter entries the local node
 * supports. */
#define CONFIG_BT_MESH_PROXY_FILTER_SIZE  `ble.filterSize`

/* This option determines for how long the local node advertises using Node
 * Identity. The given value is in seconds. The specification limits this to 60
 * seconds, and implies that to be the appropriate value as well, so just
 * leaving this as the default is the safest option. */
#define CONFIG_BT_MESH_NODE_ID_TIMEOUT  `ble.nodeIdTimeout`
% }

/* Maximum number of simultaneous Bluetooth connections supported.
 * This parameter is aligned with MAX_NUM_BLE_CONNS
 */
#define CONFIG_BT_MAX_CONN `ble.maxConnNum`

%if(!ble.proxy)
% {
#define ERPC_REMOVE__bt_mesh_proxy_identity_enable
% }
/* ------------------------------------------------------------------------- */

%if(ble.friend)
% {
/* ------------------------------------------------------------------------- */
// Friend
/* ------------------------------------------------------------------------- */
/* Enable this option to be able to act as a Friend Node. */
#define CONFIG_BT_MESH_FRIEND 1

#define CONFIG_BT_MESH_FRIEND_ENABLED 1

/* Receive Window in milliseconds supported by the Friend node. */
#define CONFIG_BT_MESH_FRIEND_RECV_WIN `ble.recieveWindow`

/* Minimum number of buffers available to be stored for each local Friend
 * Queue. */
#define CONFIG_BT_MESH_FRIEND_QUEUE_SIZE `ble.queueSize`

/* Size of the Subscription List that can be supported by a Friend node for a
 * Low Power node. */
#define CONFIG_BT_MESH_FRIEND_SUB_LIST_SIZE `ble.subscriptionListSize`

/* Number of Low Power Nodes the Friend can have a Friendship with
 * simultaneously. */
#define CONFIG_BT_MESH_FRIEND_LPN_COUNT `ble.lpnCount`

/* Number of incomplete segment lists that we track for each LPN that we are
 * Friends for. In other words, this determines how many elements we can
 * simultaneously be receiving segmented messages from when the messages are
 * going into the Friend queue. */
#define CONFIG_BT_MESH_FRIEND_SEG_RX `ble.segmentLists`
/* ------------------------------------------------------------------------- */
% }

/* ------------------------------------------------------------------------- */
// LPN
/* ------------------------------------------------------------------------- */

%if(ble.lowPower)
% {
/* Enable this option to be able to act as a Low Power Node. */
#define CONFIG_BT_MESH_LOW_POWER 1

/* Perform the Friendship establishment using low power, with the help of a
 * reduced scan duty cycle. The downside of this is that the node may miss out
 * on messages intended for it until it has successfully set up Friendship
 * with a Friend node. */
#define CONFIG_BT_MESH_LPN_ESTABLISHMENT `ble.friendshipEstablishment`

/* Automatically enable LPN functionality once provisioned and start looking
 * for Friend nodes. If this option is disabled LPN mode needs to be manually
 * enabled by calling bt_mesh_lpn_set(true). */
#define CONFIG_BT_MESH_LPN_AUTO `ble.autoEnableLpn`

/* Time in seconds from the last received message, that the node will wait
 * before starting to look for Friend nodes. */
#define CONFIG_BT_MESH_LPN_AUTO_TIMEOUT `ble.autoEnableLpnTimeout`

/* Time in seconds between Friend Requests, if a previous Friend Request did
 * not receive any acceptable Friend Offers. */
#define CONFIG_BT_MESH_LPN_RETRY_TIMEOUT `ble.retryTimeout`

/* The contribution of the RSSI measured by the Friend node used in Friend
 * Offer Delay calculations. 0 = 1, 1 = 1.5, 2 = 2, 3 = 2.5. */
#define CONFIG_BT_MESH_LPN_RSSI_FACTOR `ble.rssiFactor`

/* The contribution of the supported Receive Window used in Friend Offer Delay
 * calculations. 0 = 1, 1 = 1.5, 2 = 2, 3 = 2.5. */
#define CONFIG_BT_MESH_LPN_RECV_WIN_FACTOR `ble.receiveWindowFactor`

/* The MinQueueSizeLog field is defined as log_2(N), where N is the minimum
 * number of maximum size Lower Transport PDUs that the Friend node can store
 * in its Friend Queue. As an example, MinQueueSizeLog value 1 gives N = 2, and
 * value 7 gives N = 128. */
#define CONFIG_BT_MESH_LPN_MIN_QUEUE_SIZE `ble.minQueueSize`

/* The ReceiveDelay is the time between the Low Power node sending a request
 * and listening for a response. This delay allows the Friend node time to
 * prepare the response. The value is in units of milliseconds. */
#define CONFIG_BT_MESH_LPN_RECV_DELAY `ble.receiveDelay`

/* PollTimeout timer is used to measure time between two consecutive requests
 * sent by the Low Power node. If no requests are received by the Friend node
 * before the PollTimeout timer expires, then the friendship is considered
 * terminated. The value is in units of 100 milliseconds, so e.g. a value of
 * 300 means 30 seconds. */
#define CONFIG_BT_MESH_LPN_POLL_TIMEOUT `ble.pollTimeout`

/* The initial value of the PollTimeout timer when Friendship gets established
 * for the first time. After this the timeout will gradually grow toward the
 * actual PollTimeout, doubling in value for each iteration. The value is in
 * units of 100 milliseconds, so e.g. a value of 300 means 30 seconds. */
#define CONFIG_BT_MESH_LPN_INIT_POLL_TIMEOUT `ble.initialValuePollTimeout`

/* Latency in milliseconds that it takes to enable scanning. This is in
 * practice how much time in advance before the Receive Window that scanning is
 * requested to be enabled. */
#define CONFIG_BT_MESH_LPN_SCAN_LATENCY `ble.scanLatency`

/* Maximum number of groups that the LPN can subscribe to. */
#define CONFIG_BT_MESH_LPN_GROUPS `ble.groups`
% }
%else
% {
#define ERPC_REMOVE__bt_mesh_lpn_set
#define ERPC_REMOVE__bt_mesh_lpn_set_cb
#define ERPC_REMOVE__bt_mesh_lpn_poll
% }

/* ------------------------------------------------------------------------- */
// Configuration Server
/* ------------------------------------------------------------------------- */
#define CONFIG_BT_MESH_DEFAULT_TTL                      `ble.default_ttl`
#define CONFIG_BT_MESH_NETWORK_TRANSMIT_COUNT           `ble.net_transmit_count`
#define CONFIG_BT_MESH_NETWORK_TRANSMIT_INTERVAL        `ble.net_transmit_int_ms`
#define CONFIG_BT_MESH_RELAY_RETRANSMIT_COUNT           `ble.relay_retransmit_count`
#define CONFIG_BT_MESH_RELAY_RETRANSMIT_INTERVAL        `ble.relay_retransmit_int_ms`
#define CONFIG_BT_MESH_TX_SEG_RETRANS_COUNT             `ble.trans_msg_seg_retrans_attempts`
#define CONFIG_BT_MESH_TX_SEG_RETRANS_TIMEOUT_UNICAST   `ble.trans_msg_seg_retrans_int_unicast`
#define CONFIG_BT_MESH_TX_SEG_RETRANS_TIMEOUT_GROUP     `ble.trans_msg_seg_retrans_int_group`
%if(ble.proxy)
%{
#define CONFIG_BT_MESH_GATT_PROXY_ENABLED 1
%}
%if(ble.beaconState)
%{
#define CONFIG_BT_MESH_BEACON_ENABLED 1
%}

/* ------------------------------------------------------------------------- */


#endif /* TI_BLE_MESH_CONFIG_H */
