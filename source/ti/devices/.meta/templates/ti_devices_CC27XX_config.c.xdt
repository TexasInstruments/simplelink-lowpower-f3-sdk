%%{
/*
 * Copyright (c) 2022-2024, Texas Instruments Incorporated - http://www.ti.com
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * *  Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * *  Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * *  Neither the name of Texas Instruments Incorporated nor the names of
 *    its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

/*
 *  ======== ti_devices_cc27xx_config.c.xdt ========
 */

    var module = system.modules['/ti/devices/CCFG'];
    var inst = module.$static;
    const Common = system.getScript("/ti/drivers/Common.js");
    var i = 0;
    const isCC27xxx7 = system.deviceData.deviceId.match(/CC27...7/) !== null;
%%}
/*
 *  ======== ti_devices_config.c ========
 *  Customer Configuration for CC27XX devices.
 *
 *  DO NOT EDIT - This file is generated by the SysConfig tool.
 *
 */


#include <ti/devices/DeviceFamily.h>
#include DeviceFamily_constructPath(inc/hw_ccfg.h)
#include DeviceFamily_constructPath(inc/hw_scfg.h)
% if (inst.authMethod != "No Authentication") {
#include "sb_key_ring_init.h"
% } else {

#define SCFG_INVALID_KEY_ENTRY \
        .type = 0, .keyHash = {0}, .crc32 = 0, .status = 0,

% }
% if(inst.useHwInitCopyList){
#include "`inst.hwInitCopyListFile`"    //hardware initialisation copy list
% }
% if(inst.enableUserRecord){
#include "`inst.userRecordFile`"    //user record
% }
%
% if(Common.isCName(inst.pAppVtorStr)) {
extern void (*const `inst.pAppVtorStr`[])(void);
% }
% if(Common.isCName(inst.pBldrVtorStr)) {
extern void (*const `inst.pBldrVtorStr`[])(void);
% }

#if defined(__IAR_SYSTEMS_ICC__)
__root const ccfg_t ccfg @ ".ccfg" =
#elif defined(__TI_COMPILER_VERSION__)
#pragma DATA_SECTION(ccfg, ".ccfg")
#pragma RETAIN(ccfg)
const ccfg_t ccfg =
#elif defined(__llvm__)
const ccfg_t ccfg __attribute__((section(".ccfg"), retain)) =
#else
const ccfg_t ccfg __attribute__((section(".ccfg"), used)) =
#endif
{
% if(inst.bldrSetting == "Default FCFG bootloader, with CCFG settings"){
    .bootCfg.pBldrVtor = CCFG_BC_PBLDR_USE_FCFG,
% }
% else if(inst.bldrSetting == "User-specific bootloader"){
%   if(Common.isCName(inst.pBldrVtorStr)) {
    .bootCfg.pBldrVtor = (void*)&`inst.pBldrVtorStr`,
%   } else {
    .bootCfg.pBldrVtor = (void*)`inst.pBldrVtorStr`,
%   }
% }
% else if(inst.bldrSetting == "Any bootloader forbidden"){
    .bootCfg.pBldrVtor = XCFG_BC_PBLDR_FORBID,
% }
% else {
    .bootCfg.pBldrVtor = XCFG_BC_PBLDR_UNDEF,
% }

% if(inst.bldrEnabled){
    .bootCfg.bldrParam.serialRomBldrParamStruct.bldrEnabled = XCFG_BC_BLDR_EN,
% } else {
    .bootCfg.bldrParam.serialRomBldrParamStruct.bldrEnabled = XCFG_BC_BLDR_DIS,
% }
    .bootCfg.bldrParam.serialRomBldrParamStruct.serialIoCfgIndex = `inst.serialIoCfgIndex`,
    .bootCfg.bldrParam.serialRomBldrParamStruct.pinTriggerDio = `inst.pinTriggerDio`,
% if(inst.pinTriggerEnabled){
    .bootCfg.bldrParam.serialRomBldrParamStruct.pinTriggerEnabled = XCFG_BC_PINTRIG_EN,
% } else {
    .bootCfg.bldrParam.serialRomBldrParamStruct.pinTriggerEnabled = XCFG_BC_PINTRIG_DIS,
% }
% if(inst.pinTriggerLevel === "HIGH"){
    .bootCfg.bldrParam.serialRomBldrParamStruct.pinTriggerLevel = XCFG_BC_PINTRIG_LEVEL_HI,
% } else {
    .bootCfg.bldrParam.serialRomBldrParamStruct.pinTriggerLevel = XCFG_BC_PINTRIG_LEVEL_LO,
% }
% if(Common.isCName(inst.pAppVtorStr)) {
    .bootCfg.pAppVtor = (void*)&`inst.pAppVtorStr`,
% } else {
    .bootCfg.pAppVtor = (void*)`inst.pAppVtorStr`,
% }

    /* Set to 0. This checksum must be calculated and updated prior to
     * programming the application to the device (this is normally handled as a
     * post-build step, or by the flashloader).
     */
    .bootCfg.crc32 = 0x00000000,
% if(isCC27xxx7) {
    .hwOpts = {0xFFFFFFFF, 0xDFFFFFFF},
% } else {
    .hwOpts = {0xFFFFFFFF, 0xFFFFFFFF},
% }

% if(inst.allowDebugPort){
    .permissions.allowDebugPort = CCFG_PERMISSION_ALLOW,
% } else {
    .permissions.allowDebugPort = CCFG_PERMISSION_FORBID,
% }
% if(inst.allowEnergyTrace){
    .permissions.allowEnergyTrace = CCFG_PERMISSION_ALLOW,
% } else {
    .permissions.allowEnergyTrace = CCFG_PERMISSION_FORBID,
% }
% if(inst.allowFlashVerify){
    .permissions.allowFlashVerify = CCFG_PERMISSION_ALLOW,
% } else {
    .permissions.allowFlashVerify = CCFG_PERMISSION_FORBID,
% }
% if(inst.allowFlashProgram){
    .permissions.allowFlashProgram = CCFG_PERMISSION_ALLOW,
% } else {
    .permissions.allowFlashProgram = CCFG_PERMISSION_FORBID,
% }
% if(inst.allowChipErase){
    .permissions.allowChipErase = CCFG_PERMISSION_ALLOW,
% } else {
    .permissions.allowChipErase = CCFG_PERMISSION_FORBID,
% }
    .permissions.allowToolsClientMode = CCFG_PERMISSION_ALLOW,
    .permissions.allowFakeStby = CCFG_PERMISSION_ALLOW,
% if(inst.allowReturnToFactory){
    .permissions.allowReturnToFactory = CCFG_PERMISSION_ALLOW,
% } else {
    .permissions.allowReturnToFactory = CCFG_PERMISSION_FORBID,
% }

    .misc.saciTimeoutOverride = 0U,

% if(inst.allowMainAppErase){
    .misc.allowMainAppErase    = CCFG_PERMISSION_ALLOW,
% } else {
    .misc.allowMainAppErase    = CCFG_PERMISSION_FORBID,
% }

    .flashProt.writeEraseProt.mainSectors0_31 = 0x`inst.writeEraseProt_mainSectors0_31.toString(16)`,
    .flashProt.writeEraseProt.mainSectors32_255 = 0x`inst.writeEraseProt_mainSectors32_255.toString(16)`,
    .flashProt.writeEraseProt.mainSectors256_511 = 0x`inst.writeEraseProt_mainSectors256_511.toString(16)`,

    .flashProt.writeEraseProt.ccfgSector = `inst.writeEraseProt_ccfgSector ? 0 : 1`,
    .flashProt.writeEraseProt.fcfgSector = `inst.writeEraseProt_fcfgSector ? 0 : 1`,
    .flashProt.writeEraseProt.engrSector = `inst.writeEraseProt_engrSector ? 0 : 1`,
    .flashProt.writeEraseProt.scfgSector = `inst.writeEraseProt_scfgSector ? 0 : 1`,
    .flashProt.writeEraseProt.vlogSector = `inst.writeEraseProt_vlogSector ? 0 : 1`,

    .flashProt.readProt.mainSectors = 0x`inst.mainSectors.toString(16)`,
    .flashProt.readProt.ccfgSector = 0x`inst.ccfgSector.toString(16)`,

    .flashProt.chipEraseRetain.mainSectors0_31 = 0x`inst.chipEraseRetain_mainSectors0_31.toString(16)`,
    .flashProt.chipEraseRetain.mainSectors32_255 = 0x`inst.chipEraseRetain_mainSectors32_255.toString(16)`,
    .flashProt.chipEraseRetain.mainSectors256_511 = 0x`inst.chipEraseRetain_mainSectors256_511.toString(16)`,

% if(inst.useHwInitCopyList){
    .hwInitCopyList = {`inst.hwInitCopyListMacro`},

% }
    /* Set to 0. This checksum (across hwOpts through hwInitCopyList) must be
     * calculated and updated prior to programming the application to the device
     * (this is normally handled as a post-build step, or by the flashloader).
     */
    .crc32 = 0x00000000,

% if(inst.enableUserRecord){
    .userRecord = {`inst.userRecordMacro`},

% }
% else {
    /* No user record */
%   // Note, we also don't initialize userRecord.crc32.  The user is not
%   // providing a user record, there's no requirement (ROM-wise) for the
%   // .userRecord.crc32 to be initialized.
%}

% if(inst.debugAuthorization == "Require debug authentication"){
    .debugCfg.authorization = CCFG_DBGAUTH_REQAUTH,
% } else if (inst.debugAuthorization == "Non-Invasive only"){
    .debugCfg.authorization = CCFG_DBGAUTH_ONLY_NON_INVASIVE,
% } else if(inst.debugAuthorization == "Debug not allowed"){
    .debugCfg.authorization = CCFG_DBGAUTH_DBGFORBID,
% } else {
    .debugCfg.authorization = CCFG_DBGAUTH_DBGOPEN,
% }

    /* Set to 0. This checksum must be calculated and updated prior to
     * programming the application to the device (this is normally handled as a
     * post-build step, or by the flashloader).
     */
    .debugCfg.crc32 = 0x00000000,
};

#if defined(__IAR_SYSTEMS_ICC__)
__root const scfg_t scfg @ ".scfg" =
#elif defined(__TI_COMPILER_VERSION__)
#pragma DATA_SECTION(scfg, ".scfg")
#pragma RETAIN(scfg)
const scfg_t scfg =
#elif defined(__llvm__)
/* Push current set of diagnostics */
#pragma clang diagnostic push
/* Ignore warnings about overriding struct members in the initialiser below.
 * This is required only for ticlang.
 */
#pragma clang diagnostic ignored "-Winitializer-overrides"
const scfg_t scfg __attribute__((section(".scfg"), retain)) =
#else
const scfg_t scfg __attribute__((section(".scfg"), used)) =
#endif
{
    SCFG_DEFAULT_VALUES,
%%{
var tempArray = Common.hexToBytes(inst.hsmPublicKeyHash, 32);
var arrStr = "";
var byteStr;
for(i=0; i<tempArray.length; i++){
    byteStr = "0x" + tempArray[i].toString(16).padStart(2,'0');
    if((i+1)%8 || i==0){
        arrStr += byteStr + ", ";
    } else if(i!=tempArray.length-1){
        /* Pad the beginning of each line so the initialiser array looks aligned */
        arrStr += byteStr + ",\n                             ";
    } else {
        arrStr += byteStr;
    }
}
%%}

    /* Overwrite default SCFG values */
    .hsmCfg.publicKeyHash = {`arrStr`},
% if (inst.authMethod != "No Authentication") {
    /* Boot Seed configuration */
    .bootSeedOffset = 0x`inst.bootSeedOffset.toString(16)`,

% if(inst.scfgAllowDebugPort){
    .permissions.allowDebugPort = SCFG_PERMISSION_ALLOW,
% } else {
    .permissions.allowDebugPort = SCFG_PERMISSION_FORBID,
% }
% if(inst.scfgAllowEnergyTrace){
    .permissions.allowEnergyTrace = SCFG_PERMISSION_ALLOW,
% } else {
    .permissions.allowEnergyTrace = SCFG_PERMISSION_FORBID,
% }
% if(inst.scfgAllowFlashVerify){
    .permissions.allowFlashVerify = SCFG_PERMISSION_ALLOW,
% } else {
    .permissions.allowFlashVerify = SCFG_PERMISSION_FORBID,
% }
% if(inst.scfgAllowFlashProgram){
    .permissions.allowFlashProgram = SCFG_PERMISSION_ALLOW,
% } else {
    .permissions.allowFlashProgram = SCFG_PERMISSION_FORBID,
% }
% if(inst.scfgAllowChipErase){
    .permissions.allowChipErase = SCFG_PERMISSION_ALLOW,
% } else {
    .permissions.allowChipErase = SCFG_PERMISSION_FORBID,
% }
% if(inst.scfgAllowToolsClientMode){
    .permissions.allowToolsClientMode = SCFG_PERMISSION_ALLOW,
% } else {
    .permissions.allowToolsClientMode = SCFG_PERMISSION_FORBID,
% }
% if(inst.scfgAllowReturnToFactory){
    .permissions.allowReturnToFactory = SCFG_PERMISSION_ALLOW,
% } else {
    .permissions.allowReturnToFactory = SCFG_PERMISSION_FORBID,
% }
% if(inst.scfgAllowMainAppErase){
    .permissions.allowMainAppErase = SCFG_PERMISSION_ALLOW,
% } else {
    .permissions.allowMainAppErase = SCFG_PERMISSION_FORBID,
% }

%   if (inst.ssbEnabled) {
    /* Secure Secondary Bootloader slot configuration */
    .flashCfg.flashLayout.bldrSlot.addr = 0x`inst.ssbStart.toString(16)`,
    .flashCfg.flashLayout.bldrSlot.len = 0x`inst.ssbLen.toString(16)`,
%   }

    /* Primary 0 slot configuration */
%   if (system.modules["/ti/utils/TrustZone"]) {
    .flashCfg.flashLayout.primaryAppSlots[0].addr = 0x`inst.prim0StartSecure.toString(16)`,
    .flashCfg.flashLayout.primaryAppSlots[0].len = 0x`inst.prim0LenSecure.toString(16)`,

    /* Primary 1 slot configuration */
    .flashCfg.flashLayout.primaryAppSlots[1].addr = 0x`inst.prim1Start.toString(16)`,
    .flashCfg.flashLayout.primaryAppSlots[1].len = 0x`inst.prim1Len.toString(16)`,

    /* Secondary 0 slot configuration */
    .flashCfg.flashLayout.secondaryAppSlots[0].addr = 0x`inst.sec0StartSecure.toString(16)`,
    .flashCfg.flashLayout.secondaryAppSlots[0].len = 0x`inst.sec0LenSecure.toString(16)`,

    /* Secondary 1 slot configuration */
    .flashCfg.flashLayout.secondaryAppSlots[1].addr = 0x`inst.sec1Start.toString(16)`,
    .flashCfg.flashLayout.secondaryAppSlots[1].len = 0x`inst.sec1Len.toString(16)`,
%   } else {
    .flashCfg.flashLayout.primaryAppSlots[0].addr = 0x`inst.prim0StartSingle.toString(16)`,
    .flashCfg.flashLayout.primaryAppSlots[0].len = 0x`inst.prim0LenSingle.toString(16)`,

    /* Secondary 0 slot configuration */
    .flashCfg.flashLayout.secondaryAppSlots[0].addr = 0x`inst.sec0StartSingle.toString(16)`,
    .flashCfg.flashLayout.secondaryAppSlots[0].len = 0x`inst.sec0LenSingle.toString(16)`,
%   }

% if (inst.authMethod == "Signature") {
    .secBootCfg.policyCfg.authMethod = SCFG_POLICY_SIGNATURE,
% } else if (inst.authMethod == "Hash Lock") {
    .secBootCfg.policyCfg.authMethod = SCFG_POLICY_HASH_LOCK,
% }

% if (inst.authAlg == "RSA 3K PKCS") {
    .secBootCfg.policyCfg.authAlgorithm = SCFG_POLICY_ALG_RSA_3K_SHA256,
% } else if (inst.authAlg == "ECDSA P256") {
    .secBootCfg.policyCfg.authAlgorithm = SCFG_POLICY_ALG_ECDSA_P256_SHA256,
% } else if (inst.authAlg == "ECDSA P521") {
    .secBootCfg.policyCfg.authAlgorithm = SCFG_POLICY_ALG_ECDSA_P521_SHA512,
% }

% if (inst.mode == "Overwrite") {
    .secBootCfg.policyCfg.mode = SCFG_POLICY_OVRWRT,
% } else if (inst.mode == "XIP Revert Enabled") {
    .secBootCfg.policyCfg.mode = SCFG_POLICY_XIP_REVERT_ENABLED,
% } else if (inst.mode == "XIP Revert Disabled") {
    .secBootCfg.policyCfg.mode = SCFG_POLICY_XIP_REVERT_DISABLED,
% }

    .secBootCfg.keyUpdateKeyHash = SCFG_KEY_RING_MASTER_HASH,
    SCFG_KEY_RING_CONFIG,
% } else {
    .keyRingCfg = {
        .keyEntries = {
%     for (i=0; i < 18 /* SCFG_KEY_HASH_RING_NUM */; i++) {
            { SCFG_INVALID_KEY_ENTRY },
%     }
        },
    },
% }

    /* Set to 0. This checksum must be calculated and updated prior to
     * programming the application to the device (this is normally handled as a
     * post-build step, or by the flashloader).
     */
    .crc32 = 0x00000000,
};

#ifdef __llvm__
/* Restore the original set of diagnostics */
#pragma clang diagnostic pop
#endif
