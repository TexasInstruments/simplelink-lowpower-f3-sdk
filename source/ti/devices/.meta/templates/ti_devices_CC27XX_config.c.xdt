%%{
/*
 * Copyright (c) 2022-2023 Texas Instruments Incorporated - http://www.ti.com
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * *  Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * *  Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * *  Neither the name of Texas Instruments Incorporated nor the names of
 *    its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

/*
 *  ======== ti_devices_cc27xx_config.c.xdt ========
 */

    var module = system.modules['/ti/devices/CCFG'];
    var inst = module.$static;
    const Common = system.getScript("/ti/drivers/Common.js");
    var i = 0;

%%}
/*
 *  ======== ti_devices_config.c ========
 *  Customer Configuration for CC27XX devices.
 *
 *  DO NOT EDIT - This file is generated by the SysConfig tool.
 *
 */

#include <ti/devices/DeviceFamily.h>
#include DeviceFamily_constructPath(inc/hw_ccfg.h)
#include DeviceFamily_constructPath(inc/hw_scfg.h)
% if(inst.useHwInitCopyList){
#include "`inst.hwInitCopyListFile`"    //hardware initialisation copy list
% }
% if(inst.enableUserRecord){
#include "`inst.userRecordFile`"    //user record
% }

#if defined(__IAR_SYSTEMS_ICC__)
__root const ccfg_t ccfg @ ".ccfg" =
#elif defined(__TI_COMPILER_VERSION__)
#pragma DATA_SECTION(ccfg, ".ccfg")
#pragma RETAIN(ccfg)
const ccfg_t ccfg =
#elif defined(__llvm__)
const ccfg_t ccfg __attribute__((section(".ccfg"), retain)) =
#else
const ccfg_t ccfg __attribute__((section(".ccfg"), used)) =
#endif
{

% if(inst.bldrSetting == "Default FCFG bootloader, with CCFG settings"){
    .bootCfg.pBldrVtor = CCFG_BC_PBLDR_USE_FCFG,
% }
% else if(inst.bldrSetting == "User-specific bootloader"){
    .bootCfg.pBldrVtor = (void*)0x`inst.pBldrVtor.toString(16)`,
% }
% else if(inst.bldrSetting == "Any bootloader forbidden"){
    .bootCfg.pBldrVtor = XCFG_BC_PBLDR_FORBID,
% }
% else {
    .bootCfg.pBldrVtor = XCFG_BC_PBLDR_UNDEF,
% }

% if(inst.bldrEnabled){
    .bootCfg.bldrParam.serialRomBldrParamStruct.bldrEnabled = XCFG_BC_BLDR_EN,
% } else {
    .bootCfg.bldrParam.serialRomBldrParamStruct.bldrEnabled = XCFG_BC_BLDR_DIS,
% }
    .bootCfg.bldrParam.serialRomBldrParamStruct.serialIoCfgIndex = `inst.serialIoCfgIndex`,
    .bootCfg.bldrParam.serialRomBldrParamStruct.pinTriggerDio = `inst.pinTriggerDio`,
% if(inst.pinTriggerEnabled){
    .bootCfg.bldrParam.serialRomBldrParamStruct.pinTriggerEnabled = XCFG_BC_PINTRIG_EN,
% } else {
    .bootCfg.bldrParam.serialRomBldrParamStruct.pinTriggerEnabled = XCFG_BC_PINTRIG_DIS,
% }
% if(inst.pinTriggerLevel === "HIGH"){
    .bootCfg.bldrParam.serialRomBldrParamStruct.pinTriggerLevel = XCFG_BC_PINTRIG_LEVEL_HI,
% } else {
    .bootCfg.bldrParam.serialRomBldrParamStruct.pinTriggerLevel = XCFG_BC_PINTRIG_LEVEL_LO,
% }
    .bootCfg.pAppVtor = (void*)0x`inst.pAppVtor.toString(16)`,

    .hwOpts = {0x`inst.hwOpts0.toString(16)`, 0x`inst.hwOpts1.toString(16)`},

% if(inst.allowDebugPort){
    .permissions.allowDebugPort = CCFG_PERMISSION_ALLOW,
% } else {
    .permissions.allowDebugPort = CCFG_PERMISSION_FORBID,
% }
% if(inst.allowEnergyTrace){
    .permissions.allowEnergyTrace = CCFG_PERMISSION_ALLOW,
% } else {
    .permissions.allowEnergyTrace = CCFG_PERMISSION_FORBID,
% }
% if(inst.allowFlashVerify){
    .permissions.allowFlashVerify = CCFG_PERMISSION_ALLOW,
% } else {
    .permissions.allowFlashVerify = CCFG_PERMISSION_FORBID,
% }
% if(inst.allowFlashProgram){
    .permissions.allowFlashProgram = CCFG_PERMISSION_ALLOW,
% } else {
    .permissions.allowFlashProgram = CCFG_PERMISSION_FORBID,
% }
% if(inst.allowChipErase){
    .permissions.allowChipErase = CCFG_PERMISSION_ALLOW,
% } else {
    .permissions.allowChipErase = CCFG_PERMISSION_FORBID,
% }
% if(inst.allowToolsClientMode){
    .permissions.allowToolsClientMode = CCFG_PERMISSION_ALLOW,
% } else {
    .permissions.allowToolsClientMode = CCFG_PERMISSION_FORBID,
% }
% if(inst.allowFakeStby){
    .permissions.allowFakeStby = CCFG_PERMISSION_ALLOW,
% } else {
    .permissions.allowFakeStby = CCFG_PERMISSION_FORBID,
% }
% if(inst.allowReturnToFactory){
    .permissions.allowReturnToFactory = CCFG_PERMISSION_ALLOW,
% } else {
    .permissions.allowReturnToFactory = CCFG_PERMISSION_FORBID,
% }

% if(inst.saciTimeoutOverride){
    .misc.saciTimeoutOverride = 1U,
    .misc.saciTimeoutExp = `inst.saciTimeoutExp`,
% } else {
    .misc.saciTimeoutOverride = 0U,
% }

    .flashProt.writeEraseProt.mainSectors0_31 = 0x`inst.writeEraseProt_mainSectors0_31.toString(16)`,
    .flashProt.writeEraseProt.mainSectors32_255 = 0x`inst.writeEraseProt_mainSectors32_255.toString(16)`,
    .flashProt.writeEraseProt.mainSectors256_511 = 0x`inst.writeEraseProt_mainSectors256_511.toString(16)`,

    .flashProt.writeEraseProt.ccfgSector = `inst.writeEraseProt_ccfgSector ? 0 : 1`,
    .flashProt.writeEraseProt.fcfgSector = `inst.writeEraseProt_fcfgSector ? 0 : 1`,
    .flashProt.writeEraseProt.engrSector = `inst.writeEraseProt_engrSector ? 0 : 1`,
    .flashProt.writeEraseProt.scfgSector = `inst.writeEraseProt_scfgSector ? 0 : 1`,
    .flashProt.writeEraseProt.vlogSector = `inst.writeEraseProt_vlogSector ? 0 : 1`,

    .flashProt.readProt.mainSectors = 0x`inst.mainSectors.toString(16)`,
    .flashProt.readProt.ccfgSector = 0x`inst.ccfgSector.toString(16)`,

    .flashProt.chipEraseRetain.mainSectors0_31 = 0x`inst.chipEraseRetain_mainSectors0_31.toString(16)`,
    .flashProt.chipEraseRetain.mainSectors32_255 = 0x`inst.chipEraseRetain_mainSectors32_255.toString(16)`,
    .flashProt.chipEraseRetain.mainSectors256_511 = 0x`inst.chipEraseRetain_mainSectors256_511.toString(16)`,

% if(inst.useHwInitCopyList){
    .hwInitCopyList = {`inst.hwInitCopyListMacro`},
% }
% if(inst.enableUserRecord){
    .userRecord = {`inst.userRecordMacro`},
% }
% if(inst.debugAuthorization == "Require debug authentication"){
    .debugCfg.authorization = CCFG_DBGAUTH_REQPASSWD,
% }
% else if(inst.debugAuthorization == "Debug not allowed"){
    .debugCfg.authorization = CCFG_DBGAUTH_DBGFORBID,
% }
% else {
    .debugCfg.authorization = CCFG_DBGAUTH_DBGOPEN,
% }
% if(inst.debugAllowBldr){
    .debugCfg.allowBldr = CCFG_DBGBLDR_ALLOW,
% } else {
    .debugCfg.allowBldr = CCFG_DBGBLDR_FORBID,
% }
%%{
var tempArray = Common.hexToBytes(inst.debugPwdId, 8);
var arrStr = "";
var byteStr;
for(i=0; i<tempArray.length; i++){
    byteStr = "0x" + tempArray[i].toString(16).padStart(2,'0');
    if(i!=tempArray.length-1){
        arrStr += byteStr + ", ";
    } else {
        arrStr += byteStr;
    }
}
%%}
    .debugCfg.pwdId = {`arrStr`},
%%{
tempArray = Common.hexToBytes(inst.debugPwdHash, 32);
arrStr = "";
for(i=0; i<tempArray.length; i++){
    byteStr = "0x" + tempArray[i].toString(16).padStart(2,'0');
    if((i+1)%8 || i==0){
        arrStr += byteStr + ", ";
    } else if(i!=tempArray.length-1){
        arrStr += byteStr + ",\n                         ";
    } else {
        arrStr += byteStr;
    }
}
%%}
    .debugCfg.pwdHash = {`arrStr`},

};

#if defined(__IAR_SYSTEMS_ICC__)
__root const scfg_t scfg @ ".scfg" =
#elif defined(__TI_COMPILER_VERSION__)
#pragma DATA_SECTION(scfg, ".scfg")
#pragma RETAIN(scfg)
const scfg_t scfg =
#elif defined(__llvm__)
/* Push current set of diagnostics */
#pragma clang diagnostic push
/* Ignore warnings about overriding struct members in the initialiser below.
 * This is required only for ticlang.
 */
#pragma clang diagnostic ignored "-Winitializer-overrides"
const scfg_t scfg __attribute__((section(".scfg"), retain)) =
#else
const scfg_t scfg __attribute__((section(".scfg"), used)) =
#endif
{
    SCFG_DEFAULT_VALUES,
%%{
tempArray = Common.hexToBytes(inst.hsmPublicKeyHash, 32);
arrStr = "";
for(i=0; i<tempArray.length; i++){
    byteStr = "0x" + tempArray[i].toString(16).padStart(2,'0');
    if((i+1)%8 || i==0){
        arrStr += byteStr + ", ";
    } else if(i!=tempArray.length-1){
        /* Pad the beginning of each line so the initialiser array looks aligned */
        arrStr += byteStr + ",\n                             ";
    } else {
        arrStr += byteStr;
    }
}
%%}

    /* Overwrite default SCFG values */
    .hsmCfg.publicKeyHash = {`arrStr`},
    .hsmCfg.hsmSize = `inst.hsmSize`,

    .flashCfg.flashBanks.mode = `inst.flashBanksMode.match(/\(([^)]+)\)/)[1]`,
};

#ifdef __llvm__
/* Restore the original set of diagnostics */
#pragma clang diagnostic pop
#endif